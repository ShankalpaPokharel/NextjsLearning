# NextjsLearning 

<b>React framework to build web application (production ready)</b>
It uses react for building user interfaces, providedes additional features that enable you to build produciton-ready applications. These feature include routing, optimized rendering, data fetching, bundling, compiling and more. (don't need additional packages , opinions and conventions should be follwed to implement these)

## Why learn Next.js ? 
Next.js simplifies the process of building a web application for production : 

1. Routing (don't need to install thrid party, offers file base of routing)
2. API routes
3. Rendering(support both server and client side)
4. Data fetching
5. Styling
6. Optimizing
7. Dev and prod build system(focus on coding rather than setup)


## React Server Componets (RSC)

React SErver compoents is a new architecture introduced by the React team in version 18 which was quickly embraced by Nexrt.js

The architectture introduces a new way of creating React components, splitting them in two types:
- ### Server components
    - In Next.js, all components are Server components by default. 
    - They have the ability to ruun tasks like reading files or fetching data from a database.
    - However, they don't have the ability to use hooks or handle user interaction 
- ### Client Components 
    - To create a Client components, it's necessary to add ```use client``` at the top of the component file. 
    - Client components can't perform tasks like reading files, but they have the ability to use hooks and manage interactions. 
    - It is traditional react components. 

## Routing

Next.js has a file-system based routing mechanism
URL paths that users can access in the browser are defined by files and folders in your codebase

### Routing Conventions
All routes must be placed inside the app folder
Every file that corresponds to a route must be named page.js or page.tsx
Every folder corresponds to a path segments in the browers url

![alt text](<images/Screenshot 2024-07-03 at 1.38.12 PM.png>)


### Nested Routes

![alt text](<images/Screenshot 2024-07-03 at 1.44.40 PM.png>)
![alt text](<images/Screenshot 2024-07-03 at 1.46.01 PM.png>)

### Dynamic Routes
![alt text](<images/Screenshot 2024-07-03 at 1.47.57 PM.png>) 
![alt text](<images/Screenshot 2024-07-03 at 2.01.25 PM.png>)
![alt text](<images/Screenshot 2024-07-03 at 2.02.06 PM.png>)

### Nested Dynammic Routes

![alt text](<images/Screenshot 2024-07-03 at 2.03.55 PM.png>)

![alt text](<images/Screenshot 2024-07-03 at 2.10.09 PM.png>)
![alt text](<images/Screenshot 2024-07-03 at 2.10.51 PM.png>)

### Catch-all Segments

![alt text](<images/Screenshot 2024-07-03 at 2.14.38 PM.png>)

![alt text](<images/Screenshot 2024-07-03 at 2.26.11 PM.png>)

![alt text](<images/Screenshot 2024-07-03 at 2.27.30 PM.png>)

### Not found Page
![alt text](<images/Screenshot 2024-07-03 at 2.36.23 PM.png>)



## File Colocation
File colocation refers to the practice of organizing and placing files close to where they are used or relevant within the project structure.

To return content should be defalut export function without it page doen't return anythings

## Private Folder
Private folder indeicated that is a private implementation detail and should not be considered by the routing system. 

The folder and all its subfolders are excluded from routing

Prefix the folder name with an underscore

For separating UI logic from routing logic
For consistentlly organizing internal files across a project
For sorting and grouping files in code ediotrs
And finally, for avoiding potential naming conflicts with future Next.js file conventions. 
If you want to include an undercore in URL segments, you can prefix the foder name with "%5F" which is the URL -encoded form of an underscore, if you use %5F it will become route. 

![alt text](<images/Screenshot 2024-07-03 at 4.39.07 PM.png>)

## Route Groups
Allow us to logically group our routes and project files without affecting the URL path structure 

naming convention ```(group_name)```

Let's implement authentication routes
 - Register
 - Login
 - Forget password

![alt text](<images/Screenshot 2024-07-03 at 4.50.06 PM.png>)

## Layouts
A page is UI that is unique to a route

A layout is UI that is shared between multiple pages in the app
___________
| Header  |
-----------
| Contet  |
-----------
| Footer  |
-----------

### How to create Layouts
You c  an define a layout by default exporting a React component from a layout.js or layout.tsx file 
That component should accept a children prop that will be populated with a child page rendering

![alt text](<images/Screenshot 2024-07-03 at 5.06.12 PM.png>)

```tsx
export const metadata = {
    title: "Hello from Next.js",
    description: "Generated by Next.js",
};

export default function RootLayout({ children }: { children: React.ReactNode }) {
    return (
        <html lang="en">
            <body>
                <header style={{backgroundColor:"lightblue",padding:"1rem"}}>
                    <p>header</p>
                </header>
                {children}
                <footer style={{backgroundColor:"ghostwhite",padding:"1rem"}}>
                    <p>Footer</p>
                </footer>
            </body>
        </html>
    );
}

```

### Nested Layout
```tsx
<!-- routing-demo/src/app/products/[productId]/layout.tsx -->

export default function ProductDetailsLayout({ children }: { children: React.ReactNode }) {
    return (
        <>
            {children}
            <h2>Feature Products</h2>
        </>
    );
}

```


![alt text](<images/Screenshot 2024-07-03 at 5.14.26 PM.png>)


### Route Group Layout

Route Group uses:
 - To organize your project in a manner that doesn't affect URL
 - To selectively apply a layout to certain segments while leaving others unchanged

 ![alt text](<images/Screenshot 2024-07-03 at 5.34.34 PM.png>)


 ## Routing Metadata
 Ensuring proper search engin optimization(SEO) is crucial for increasing visibility and attractting users

 Next.js introduced the Metadata API which allows you to define metadata for each page

Metadata ensures accurate and relevant information is displyed when your pages are shared or indexed

### Configuring Metadata

- Export a static metadata object
- Export a dynamic generated Meatadata function

### Metadata rules
Both layout.tsx and page.tsx fiels can export metadata. If defined in a layout, it applies to all pages in that layout, but if defined in a pge, it applies only to that page. 

Metadata is read in order, from the root level down to the final page page level. 

When there's metadata in multiple places for the save route, but page metadata will replace layout metadata if they have the same properties. 

```ts
export const metadata = {
  title:"About Codevolution"
}

export default function page() {
  return (
    <div>Welcome about</div>
  )
}

```
```ts
import { Metadata } from "next";
import { resolve } from "path";

type Props = {
    params: { productId: string };
};

export const generateMetadata = async ({ params }: Props): Promise<Metadata> => {
    const title = await new Promise((resolve) => {
        setTimeout(() => {
            resolve(`iPhone ${params.productId}`);
        }, 100);
    });
    return { title: `Product ${title}` };
    // return { title:`Product ${params.productId}` }
};

export default function ProductDetails({ params }: Props) {
    console.log(params);
    return <div>Details about product {params.productId}</div>;
}

```


<b> You can't export both  the metadata object and generate metadata fucntion from same route segment</b>


### title Metadata
The title field's primary purpose is to define the document title
It can be either a string or an object 

```ts

import { Metadata } from "next";

export const metadata:Metadata = {
    title: {
        absolute:"",
        default:"Learning Next.js",
        template:"%s | Shankalpa"
    },
    description: "Generated by Next.js",
};

```
```ts
import { Metadata } from "next"

export const metadata:Metadata = {
  title:{
    absolute:"blog" //tille will be blog don't follow the template when use absolute
  }
}

export default function SecondBlog() {
  return (
    <div>SecondBlog Post</div>
  )
}

```



## Navigation
File based routing

We manually entered the URLKs in the browser's adress bar to navigate to the different route

User rely on UI elements like links to navigate:
 - Clicking on them or
 - Through programmatic navigation after completing an action


![alt text](<images/Screenshot 2024-07-03 at 8.23.09 PM.png>)

### Link Componet Navigation

To enable client-side navigation Next.js provides us wiht the Link component. 

The ```<Link>``` component is a React component that extends the HTML ```<a>``` element,  and it's the primary way to navigate between routes in Next.js. 

To use it, we need to import it from ```next/link```

The```replace``` attribute is used to replace the current entry in the browser's history stack instead of adding a new one. This can be useful when you want to navigate without keeping the previous URL in the history.

```tsx
import Link from "next/link"

export default function page() {
  const productId = 100
  return (
    <>
    <Link href="/"> Home</Link>
    <div>Product List</div>
    <h2> <Link href="products/1">Product 1</Link></h2>
    <h2> <Link href="products/2">Product 2</Link></h2>
    <h2> <Link href="products/3" replace>Product 3</Link></h2>
    <h2> <Link href={`products/${productId}`}>Product {productId}</Link></h2>
    </>
  )
}

```

### Active Links
```jsx
"use client"
import Link from "next/link";
import { usePathname } from "next/navigation";
import "./style.css"

const navLinks = [
    { name: "Register", href: "/register" },
    { name: "Login", href: "/login" },
    { name: "Forgot Password", href: "/forgot-password" },
];

export default function AuthLayout({ children }: {children: React.ReactNode}) {
    const pathname = usePathname()
   
    console.log(pathname)
    return (
        <div>
            {navLinks.map((link) => {
                const isActive = pathname.startsWith(link.href)
                return <Link href={link.href} key={link.name} className={isActive ? "font-bold mr-4":"text-blue-500 mr-4"}>{link.name}</Link>;
            })}
            {children}
        </div>
    );
}

```

### Navigating Pprogrammatically
![alt text](<images/Screenshot 2024-07-03 at 9.06.42 PM.png>)
![alt text](<images/Screenshot 2024-07-03 at 9.07.25 PM.png>)

```tsx
"use client"
import { useRouter } from "next/navigation"

export default function OrderProduct() {
    const router = useRouter()
    const handleClick = ()=>{
        console.log("Placing your order")
        router.push("/")
        // router.replace("/")
        // router.back()
        // router.forward()
    }
  return (
    <>
    <h1>Order Product</h1>
    <button onClick={handleClick}>Place order</button>
    </>
  )
}
```

## Templates
Templates are similar to layouts in that they wrap each child layout or page. 

But, with templates, when a user navigates between routes that share a template, a new instance of the components is mounted, DOM elements are recreated, state is not preserved , and effects are re-syncghronized. 

A template can be defined by exporting a default React component from a template.js or template.tsx file. 

Similar to layouts, templates also should accept a children props which will render the nested segments in the route. 

![alt text](<images/Screenshot 2024-07-04 at 9.45.41 AM.png>)

## Special Files
 - page.tsx
 - layout.tsx
 - template.tsx
 - not-found.tsx
 - loading.tsx
 - error.tsx

### loading.tsx 
This file allows us to create loading states that are displayed to users while a specific route segments's content is loading. 

The loading state appears immediatelly upon navigation, giveing users the assurance that the application is responsive and actively loading content. 

<b>It is like React Loading Skeleton</b>

### loading.tsk Benefits
1. You can disply the loading state as soon as a user navigates to a new route 
    The immediate feedback reassures user theat their actions has been acknowledged, reduces preceived loading times, and makes the application feel more responsive. 

2. Next.js allows the creation of shared layouts that remain interactive while new route segments are loading. 

    User can continue interacting with crtain parts of the application, asuch as a navigation menu or sidebar, if the main content is still being fetched. 


### error.tsx
![alt text](<images/Screenshot 2024-07-04 at 10.07.37 AM.png>)

Automatically wrap a route segment and it's nested children in a React Error Boundary

Create error UI tailored ot specific segents using the file-system hierarchy to adjust granularity

Isolate error to affected segments while keeping the rest of the application functional

Add functionality to attempt to recover from an error without a full page reload.

### Component Hierachy

![alt text](<images/Screenshot 2024-07-04 at 10.10.43 AM.png>)

### Recover From Error using reset
![alt text](<images/Screenshot 2024-07-04 at 10.16.38 AM.png>)


### Handling Errros in Nested Routes
Error bubble up to the closest parent error boundary

An error.tsx file will cater to errors for all its nested child segments

By positoning error.tsx files at different levels in the nested folders of a route, you can achive a more granular level of error handling. 


### Handling Errors in Layouts

An error.tsx file will handle errors for all its nested child segments

The error boundary doesn't catch error thrown here because it's nested inside the layout component.

![alt text](<images/Screenshot 2024-07-04 at 10.10.43 AM.png>)

![alt text](<images/Screenshot 2024-07-04 at 10.33.44 AM.png>)


## Parallel Routes
Parallel routes are an advanced routing mechanism that allows for the simultaneous rendering of multiple pages within the same layout

![alt text](<images/Screenshot 2024-07-04 at 10.37.26 AM.png>)


    - Parallel routes in Next.js are defined using a feature known as slots
    - Slots help structure our content in a modular fashion
    - To define a slot, we use the @folder naming convention
    - Each slot is then passed as a prop to its corresponding 'layout.ts' file.

![alt text](<images/Screenshot 2024-07-04 at 10.45.06 AM.png>)

### Parallel Routes Benefits 

A clear benefit of parallel routes is their ability to split a single layout into various slots, making the code more manageable

Independent route handling

Sub-navigation

```tsx
export default function DashboardLayout({
    children,
    users,
    revenue,
    notifications,
}: {
    children: React.ReactNode;
    users: React.ReactNode;
    revenue: React.ReactNode;
    notifications: React.ReactNode;
}) {
    return (
        <>
            <div>{children}</div>
            <div style={{ display: "flex" }}>
                <div style={{ display: "flex", flexDirection: "column" }}>
                    <div>{users}</div>
                    <div>{revenue}</div>
                </div>
                <div style={{ display: "flex", flex: 1 }}>{notifications}</div>
            </div>
        </>
    );
}

```

### Independent Route Handling 
Each slot of your layout, such as user analytics or revenue metrics, can have its own loading and error states 

This granular control is particularly beneficial in scenarios where different sections of the page load at varying speeds or encounter unique errors

![alt text](<images/Screenshot 2024-07-04 at 11.08.13 AM.png>)

### Sub-navigation in routes 

Each slot of your dashboard can essentially function as a mini-application,
complete with its own navigation and state management 

This is especially useful in a complex application such as our dashboard where different sections serve distinct purposes.

![alt text](<images/Screenshot 2024-07-04 at 11.09.57 AM.png>)


### Unmatched Routes
<b><u>Navigation from the Ul</u></b>

In the case of navigation within the Ul, Next. js retains the previously active state of a slot regardless of changes in the URL.

<b><u>Page reload</u></b>


Next.js immediately searches for a default.ts file within each unmatched slot. 

The presence of this file is critical, as it provides the default content that Next.js will render in the user interface

If this default.ts file is missing in any of the unmatched slots for the current route, Next.js will render a 404 error.


### default.tsx 


The ```default.tsx``` file in Next.js serves as a fallback to render content when the framework cannot retrieve a slot's active state from the current URL 
You have complete freedom to define the Ul for unmatched routes: you can either mirror the content found in page.ts or craft an entirely custom view

![alt text](<images/Screenshot 2024-07-04 at 11.35.29 AM.png>)


## Intercepting routes

Intercepting routes allow you to intercept or stop the default routing behaviour to present an alternate view or component when navigating through the Ul, while still preserving the intended route for scenarios like page reloads 

This can be useful if you want to show a route while keeping the context of the current page


![alt text](<images/Screenshot 2024-07-04 at 4.21.11 PM.png>)

![alt text](<images/Screenshot 2024-07-04 at 4.22.40 PM.png>)

### Intercepting Routes Conventions

    - (.) to match segment on the same level

![alt text](<images/Screenshot 2024-07-04 at 4.37.02 PM.png>)

    - (..) to match segments one level above 

![alt text](<images/Screenshot 2024-07-04 at 4.46.56 PM.png>)


    - (..)(..) to match segments two levels above
    - (...) to match segments from the root app directory


[Code of Photo gallary intercepiing routing source](https://github.com/gopinav/Next.js-14-Tutorials/tree/main/routing-demo/src/app/photo-feed)
 



## Route Handlers
We've learnt how to route to pages 

    - We can also create custom request handlers for our routes using a feature called route handlers 

    - Unlike page routes, which respond with HTML content, route handlers allow you to create RESTful endpoints, giving you full control over the response

    - There is no overhead of having to create and configure a separate server

    - Route handlers are also great for making external API requests 

    - Route handlers run server-side, ensuring that sensitive information like private keys remains secure and never gets shipped to the browser

    - Route Handlers are the equivalent of API routes in Page router

![alt text](<images/Screenshot 2024-07-04 at 5.19.11 PM.png>)

### Get Request

![alt text](<images/Screenshot 2024-07-04 at 5.34.19 PM.png>)

![alt text](<images/Screenshot 2024-07-04 at 5.35.17 PM.png>)


### Post Request 
```tsx
export async function POST(request:Request) {
    const comment = await request.json()
    console.log("comment  .. ",comment)
    const newcomment = {
        id:comments.length +1,
        text:comment.text
    }
    comments.push(newcomment)
    return new Response(JSON.stringify(newcomment),{
        headers:{
            "Content-Type":"application/json"
        },
        status:201
    })
    // return Response.json(newcomment)
}

```

### Dynamic route handler
```ts
import {comments} from "../data"

export async function GET(_request:Request,{params}:{params:{id:string}}) {
    const comment = comments.find(comment => comment.id === parseInt(params.id))
    return Response.json(comment);
}
```


### PATCH Request

```ts
// http://localhost:3000/comments/2
// json Content
// {
//     "text":"Updated Comment"
//   }
export async function PATCH(request: Request, { params }: { params: { id: string } }) {
    const body = await request.json()
    const {text}= body
    const index = comments.findIndex(
        comment =>comment.id === parseInt(params.id)
    )
    comments[index].text = text;
    
    return Response.json(comments[index]);
}

```

### Delete Request 
```ts
export async function DELETE(request: Request, { params }: { params: { id: string } }) {

   
    const index = comments.findIndex(
        comment =>comment.id === parseInt(params.id)
    )
    const deletedComment = comments[index]
    comments.splice(index,1)
    
    return Response.json(deletedComment);
    
}

```

### URL Query Parameters

```ts
import { comments } from "./data";
import { type NextRequest } from "next/server";

export async function GET(request:NextRequest) {
    const searchParams = request.nextUrl.searchParams
    const query = searchParams.get("query")
    const filteredComments = query 
        ? comments.filter(comment => comment.text.includes(query))
        : comments
    return Response.json(filteredComments)
}

```


### Redirect in Route Handler
```ts
export async function GET(_request: Request, { params }: { params: { id: string } }) {
    
    if (parseInt(params.id) >comments.length){
        redirect("/comments")
    }

    const comment = comments.find((comment) => comment.id === parseInt(params.id));
    return Response.json(comment);
}
```

### Header in Route Handlers

HTTP headers represent the metadata associated with an API request and
response.

<u><b>Request Headers </b></u>

These are sent by the client, such as a web browser, to the server. They contain essential information about the request, which helps the server understand and process it correctly.

```User-Agent``` which identifies the browser and operating system to the server. 

```Accept``` which indicates the content types like text, video, or image formats that the client can process.

```Authorization``` header used by the client to authenticate itself to the server

<u><b>Response Headers </b></u>

These are sent back from the server to the client. They provide information about the server and the data being sent in the response.

```Content-Type``` header which indicates the media type of the response. It tells the client what the data type of the returned content is, such as text/html for HTML
documents, application/json for JSON data, etc.

```ts
import { type NextRequest } from "next/server"
// or 
import { headers } from "next/headers"

export async function GET(request:NextRequest) {
    const requestHeaders = new Headers(request.headers)
    // or 
    const headerList = headers()

    console.log(requestHeaders.get("Authorization"))
    // or 
    console.log(headerList.get(("Authorization")))

    return new Response("profile data",{
       headers:{
         "Content-Type":"text/html",
         "Set-Cookie" : "theme=dark"
       }
    })
}
```

### Cookies in Route Handlers

Cookies are small pieces of data that a server sends to a user's web browser The browser may store the cookie and send it back to the same server with later requests

Cookies are mainly used for three purposes

- Session management like logins and shopping carts
- Personalization like user preferences and themes
- Tracking like recording and analyzing user behavior.

```ts
import { cookies } from "next/headers"

export async function GET(request:NextRequest) {
    const requestHeaders = new Headers(request.headers)
    // or 
    const headerList = headers()

    cookies().set("resultsPerPage","20") //one way to set cookie 
    console.log(cookies().get("resultsPerPage"))

    // get cookie 
    const theme = request.cookies.get("theme")
    console.log(theme)

    console.log(requestHeaders.get("Authorization"))
    // or 
    console.log(headerList.get(("Authorization")))

    // cookies() has delete has set size function 

    return new Response("profile data",{
       headers:{
         "Content-Type":"text/html",
         "Set-Cookie" : "theme=dark" //anoter way to set cookies
       }
    })
}
```

### Caching in Route Handlers 

Route Handlers are cached by default when using the GET method with the Response object in Next.js

How to opt out of caching?
- dynamic mode in Segment Config Option
- using the Request object with the GET method
- employing dynamic functions like headers) and cookies)

```ts
export const dynamic = "force-dynamic"; //by default it is aut o; doing this
//because after bulid time doens't change cause of caching

export async function GET() {
    return Response.json({
        time:new Date().toLocaleTimeString()
    })
}
```


## Middleware

Middleware in Next.js is a powerful feature that offers a robust way to intercept and control the flow of requests and responses within your applications 

It does this at a global level significantly enhancing features like redirection, URL rewrites, authentication, headers and cookies management, and more.
  
Middleware allows us to specify paths where it will be active
- Custom matcher config
```ts
//src/middleware.ts
import { NextResponse, type NextRequest } from "next/server";

export function middleware(request:NextRequest){
    return NextResponse.redirect(new URL("/",request.url))
}

export const config = {
    matcher:"/profile"
}

```


- Conditional statements.

```ts
import { NextResponse, type NextRequest } from "next/server";

export function middleware(request:NextRequest){
if(request.nextUrl.pathname === "/profile"){
    // return NextResponse.redirect(new URL(("/hello"),request.url))
    return NextResponse.rewrite(new URL(("/hello"),request.url)) //doesn't chagne the url but content will be change
}
}

```
```ts
import { type NextRequest, NextResponse } from "next/server";

export function middleware(request:NextRequest){
    const response = NextResponse.next()

    const themePreference = request.cookies.get("theme")

    if(!themePreference){
        response.cookies.set("theme","dark")
    }
    response.headers.set("custom-header","custom-value1")
    return response
```
### Routing Section Summary
- Route definition
- Pages and layouts
- Dynamic routes
- Route groups
- Linking and Navigation
- Handling errors in routes
- Parallel and Intercepting routes
- Route handlers and middleware


## Rendering

Rendering is the process that transforms the code you write into user interfaces 

In Next.js, choosing the right time and place to do this rendering is vital for building a performant application
CSS, SSR and RSCs

Rendering in React → Rendering in Next.js

### Client-side Rendering(CSR)
![alt text](<images/Screenshot 2024-07-04 at 8.17.39 PM.png>)

This method of rendering, where the component code is transformed into a user interface directly within the browser (the client), is known as client-side rendering(CSR)

CSR quickly became the standard for SPAs, with widespread adoption 

It wasn't long before developers began noticing some inherent drawbacks to this approach

  
#### Drawbacks of CSR

<u><b>SEO </b></u>

Generating HTML that mainly contains a single div tag is not optimal for SEO, as it provides little content for search engines to index

<b><u>Performance </u></b>

Having the browser (the client) handle all the work, such as fetching data, computing the Ul, and making the HTML interactive, can slow things down. Users might see a blank screen or a loading spinner while the page loads 

Each new feature added to the application increases the size of the JavaScript bundle, prolonging the wait time for users to see the

Reliance on JavaScript for rendering content on the client side can significantly hurt SEO, as search engines might struggle to index the content properly 

The user experience can suffer from slow load times, as the browser has to download, parse, and execute JavaScript before the user sees any meaningful content on the page

### Server-side Rendering

It significantly improves SEO because search engines can easily index the server-rendered content 

Users can immediately see the page HTML content, instead of a blank screen or loading spinner

![alt text](<images/Screenshot 2024-07-04 at 8.27.14 PM.png>)

#### Hydration

During hydration, React takes control in the browser, reconstructing the
component tree in memory based on the static HTML that was served 

It carefully plans the placement of interactive elements within this tree. Then, React proceeds to bind the necessary JavaScript logic to these elements 

This involves initializing the application state, attaching event handlers for actions such as clicks and mouseovers, and setting up any other dynamic functionalities required for a fully interactive user experience

#### Server-side Solutions

1. Static Site Generation (SSG)
2. Server-Side Rendering (SSR) 

SSG occurs at build time, when the application is deployed on the server. This results in pages that are already rendered and ready to serve. It is ideal for content that doesn't change often, like blog posts

SSR, on the other hand, renders pages on-demand in response to user requests. It is suitable for personalized content like social media feeds, where the HTML depends on the logged-in user
  
Server-Side Rendering (SSR) was a significant improvement over Client-Side Rendering(CSR), providing faster initial page loads and better SEO

#### Drawbacks of SSR

1. <b><u>You have to fetch everything before you can show anything </u></b>

Components cannot start rendering and then pause or "wait" while data is still being loaded

If a component needs to fetch data from a database or another source (like an API), this fetching must be completed before the server can begin rendering the page 

This can delay the server's response time to the browser, as the server must finish collecting all necessary data before any part of the page can be sent to the client

2. <b><u>You have to load everything before you can hydrate anythingu></u></b>

For successful hydration, where React adds interactivity to the server-rendered HTML, the component tree in the browser must exactly match the server-generated component tree 

This means that all the JavaScript for the components must be loaded on the client before you can start hydrating any of them


3. <b><u>You have to hydrate everything before you can interact with anything </u></b>

React hydrates the component tree in a single pass, meaning once it starts hydrating, it won't stop until it's finished with the entire tree 

As a consequence, all components must be hydrated before you can interact with any of them.


#### Drawbacks of SS - All or Nothing Waterfall
1. having to load the data for the entire page
2. load the JavaScript for the entire page, and
3. hydrate the entire page

create an "all or nothing" waterfall problem that spans from the server to the client, where each issue must be resolved before moving to the next one 

This is inefficient if some parts of your app are slower than others, as is often the case in real-world apps

#### Suspense SSR Architecture
Use the ```< Suspense>``` component to unlock two major SSR features:
1. HTML streaming on the server
2. Selective hydration on the client

![alt text](<images/Screenshot 2024-07-04 at 8.43.18 PM.png>)
![alt text](<images/Screenshot 2024-07-04 at 8.43.46 PM.png>)

#### HTML streaming on the Server

You don't have to fetch everything before you can show anything 

If a particular section delays the initial HTML, it can be seamlessly integrated into the stream later

This is the essence of how Suspense facilitates server-side HTML streaming

#### The other challenge 
Until the JavaScript for the main section is loaded, client-side app hydration cannot start 

And if the JavaScript bundle for the main section is large, this could significantly delay the process

to mitigate this ..
#### Code splitting 
Code splitting allows you to mark specific code segments as not immediately necessary for loading, signalling your bundler to segregate them into separate ```<script>``` tags 

Using React.lazy for code splitting enables you to separate the main section's code from the primary JavaScript bundle 

The JavaScript containing React and the code for the entire application, excluding the main section, can now be downloaded independently by the client, without having to wait for the main section's code

#### Selective Hydration on the Client

By wrapping the main section within ```<Suspense>```
, you've indicated to React that it should not prevent the rest of the page from not just streaming but also from hydrating 

This feature, called selective hydration allows for the hydration of sections as they become available, before the rest of the HTML and the JavaScript code are fully downloaded

Thanks to Selective Hydration, a heavy piece of JS doesn't prevent the rest of the page from becoming interactive

Selective Hydration offers a solution to the third issue: the necessity to "hydrate everything to interact with anything" 

React begins hydrating as soon as possible, enabling interactions with elements like the header and side navigation without waiting for the main content to be hydrated

This process is managed automatically by React 

In scenarios where multiple components are awaiting hydration, React prioritizes hydration based on user interactions

#### Drawbacks of Suspense SSR 

First, even though JavaScript code is streamed to the browser asynchronously, eventually, the entire code for a web page must be downloaded by the user 

As applications add more features, the amount of code users need to download also grows. This leads to an important question:

should users really have to download so much data?

------------------
Second, the current approach requires that all React components undergo
hydration on the client-side, irrespective of their actual need for interactivity 

This process can inefficiently spend resources and extend the loading times and time to interactivity for users, as their devices need to process and render components that might not even require client-side interaction

This leads to another question: 

should all components be hydrated, even those that don't need interactivity?
---------------------

Third, in spite of servers' superior capacity for handling intensive processing tasks, the bulk of JavaScript execution still takes place on the user's device 

This can slow down the performance, especially on devices that are not very powerful

This leads to another important question:
should so much of the work be done on the user's device?
--------------------

### The Evolution of React

CSR ---> SSR ----> Suspense for SSR 

Suspense for SSR brought us closer to a seamless rendering experience
<u><b>Challenges</b></u>
Increased bundle sizes leading to excessive downloads for users
Unnecessary hydration delaying interactivity
Extensive client-side processing that could result in poor performance


### React Server Components (RSC)

React Server Components (RSC) represent a new architecture designed by the React team 

This approach aims to leverage the strengths of both server and client environments, optimizing for efficiency, load times, and interactivity

The architecture introduces a dual-component model
- Client Components
- Server Components 

This distinction is not based on the functionality of the components but rather on where they execute and the specific environments they are designed to interact with

#### Client Components
Client Components are the familiar React components we've been using

They are typically rendered on the client-side (CS) but, they can also be rendered to HTML on the server (SSR), allowing users to immediately see the page's HTML content rather than a blank screen 

Components that primarily run on the client but can (and should) also be executed once on the server as an optimization strategy

Client Components have access to the client environment, such as the browser, allowing them to use state, effects, and event listeners to handle interactivity and also access browser-exclusive APIs like geolocation or localStorage, allowing you to build Ul for specific use cases 

In fact, the term "Client Component" doesn't signify anything new; it simply helps differentiate these components from the newly introduced Server Components

------------------

#### Server Components 

Server Components represent a new type of React component specifically
designed to operate exclusively on the server 

And unlike client components, their code stays on the server and is never downloaded to the client

This design choice offers multiple benefits to React applications

------------------
#### Benefits of Server Components
------------------
<b><u>Reduced Bundle Sizes </u></b>

Server Components do not send code to the client, allowing large dependencies to remain server-side 

This benefits users with slower internet connections or less capable devices by eliminating the need to download, parse, and execute JavaScript for these components 

Additionally, it removes the hydration step, speeding up app loading and interaction

------------------
<b><u>Direct Access to Server-side </u></b>
Resources By having direct access to server-side resources like databases or file systems, Server Components enable efficient data fetching and rendering without needing additional client-side processing 

Leveraging the server's computational power and proximity to data sources, they manage compute-intensive rendering tasks and send only interactive pieces of code to the client
------------------
<b><u>Enhanced Security </b></u>

Server Components' exclusive server-side execution enhances security by keeping sensitive data and logic, including tokens and API keys, away from the client-side

------------------
<b><u>Improved Data Fetching </b></u>

Server Components enhance data fetching efficiency 

Typically, when fetching data on the client-side using useEffect, a child component cannot begin loading its data until the parent component has finished loading its own

This sequential fetching of data often leads to poor performance 

The main issue is not the round trips themselves, but that these round trips are made from the client to the server 

Server Components enable applications to shift these sequential round trips to the server side 

By moving this logic to the server, request latency is reduced, and overall performance is imporved, eleminating client-server waterfall

------------------
<b><u>Caching </b></u> 

Rendering on the server enables caching of the results, which can be reused in subsequent requests and across different users 

This approach can significantly improve performance and reduce costs by
minimizing the amount of rendering and data fetching required for each request

------------------
<b><u>Faster Initial Page Load and First Contentful Paint </b></u>

Sixth, Initial Page Load and First Contentful Paint (FCP) are significantly improved with Server Components 

By generating HTML on the server, pages become immediately visible to users without the delay of downloading, parsing, and executing JavaScript

------------------
<b><u>Improved SEO </b></u>

Regarding Search Engine Optimization (SEO), the server-rendered HTML is fully accessible to search engine bots, enhancing the indexability of your pages

------------------
<b><u>Efficient Streaming </b></u>

Server Components allows the rendering process to be divided into manageable chunks, which are then streamed to the client as soon as they are ready

------------------

### RSC contd.

Server Components take charge of data fetching and static rendering, while Client Components are tasked with rendering the interactive elements of the application 

The bottom line is that the RSC architecture enables React applications to leverage the best aspects of both server and client rendering, all while using a single language, a single framework, and a cohesive set of APIs

 
#### RSC Key Takeaways 

------------------

RSC introduce a new way of building React apps by separating components into two types: Server Components and Client Components 

Server Components run only on the server, accessing data and preparing content without being sent to the browser, which makes the app faster for users because less information needs to download

They can't manage clicks or interactions directly 

Client Components, on the other hand, work in the user's browser and handle all the interactive parts of the app, like clicking and typing 
They can also be rendered on the server for a fast initial load of the site. This setup helps make websites faster, more secure, and easier for everyone to use,


## RSC and Next.js 

"This deep dive into the evolution of rendering in React is great, Vishwas, but how exactly does it help understand rendering in Next.js? What's the connection?"


The App Router in Next.js is built around the RSC architecture 

All the features and benefits we've discussed are already baked into the latest version of Next.js 

By understanding the evolution of React's rendering, you now have the necessary background for the rest of this section which will focus on Next.js


## RSC + Next.js


By default, every component in a Next.js app is considered a server component

In the RSC architecture and by extension in the Next.js app router, components are server components by default 

To use client components, you must include the ```use client``` directive at the top

Server components are rendered only on the server

```Client components are rendered once on the server and then on the client```

 
## RSC Rendering Lifecycle

We're going to learn about the rendering lifecycle of server and client components

In simpler terms, we'll explore how they come to life on your screen 

For React Server Components (RSC), it's important to consider three elements: your browser (the client), and on the server side, Next.js (the framework) and React (the library)

SC -server component
CC - child component 

![alt text](<images/Screenshot 2024-07-05 at 9.44.17 AM.png>)
![alt text](<images/Screenshot 2024-07-05 at 9.46.42 AM.png>)


## Server Rendering Strategies
- Static rendering
- Dynamic rendering
- Streaming


## Static rendering

Static rendering is a server rendering strategy where we generate HTML pages at the time of building our application 

This approach allows the page to be built once, cached by a CDN, and served to the client almost instantly 

This optimization also enables you to share the result of the rendering work among different users, resulting in a significant performance boost for your application 

Static rendering is particularly useful for blog pages, e-commerce product pages, documentation, and marketing pages

### How to Statically Render?

Static rendering is the default rendering strategy in the app router

All routes are automatically prepared at build time without additional setup 

<i>"Sir, throughout this video, you've mentioned that HTML is generated at build time. But there is no build for our application yet, is there? Aren't we running the application in development mode?"</i>
 

### Production Server vs Dev Server 

For production, an optimized build is created once, and you deploy that build 

A development server, on the other hand, focuses on the developer experience 

We can't afford to build our app once, make changes, rebuild, and so on 

For production builds, a page will be pre-rendered once when we run the build command

In development mode, a page will be pre-rendered for every request

### Prefetching 

Prefetching is a technique used to preload a route in the background before the user navigates to it

Routes are automatically prefetched as they become visible in the user's viewport, either when the page first loads or as it comes into view through scrolling 

For static routes, the entire route is prefetched and cached by default 

When we load the homepage, Next.js prefetches the About and Dashboard
routes, keeping them ready for instant navigation

### Static Rendering Summary

Static rendering is a strategy where the HTML is generated at build time 

Along with the HTML, the RSC payload is created for each component, and JavaScript chunks are produced for client-side component hydration in the browser 

If you navigate directly to a page route, the corresponding HTML file is served 

I you navigate to the route from a different one, the route is created on the client side using the RSC payload and JavaScript chunks, without any additional requests to the server 

Static rendering is great for performance and use cases include blogs, documentation, marketing pages etc


## Dynamic Rendering 

Dynamic rendering is a server rendering strategy where routes are rendered for each user at request time 

It is useful when a route has data that is personalized to the user or contains information that can only be known at request time, such as cookies or the URL's search parameters 

News websites, personalized e-commerce pages, and social media feeds are some examples where dynamic rendering is beneficial

### How to Dynamically Render 

During rendering, if a dynamic function is discovered, Next. js will switch to dynamically rendering the whole route 

In Next.js, these dynamic functions are: ```cookies(), headers(), and searchParams```

Using any of these will opt the whole route into dynamic rendering at request time

As a developer, you do not need to choose between static and dynamic rendering. Next.js will automatically choose the best rendering strategy for each route based on the features and APIs used

![alt text](<images/Screenshot 2024-07-05 at 10.16.28 AM.png>)


## Streaming
Streaming is a strategy that allows for progressive Ul rendering from the server

Work is divided into chunks and streamed to the client as soon as it's ready 

This enables users to see parts of the page immediately, before the entire content has finished rendering 

Streaming significantly improves both the initial page loading performance and the rendering of Ul elements that rely on slower data fetches, which would otherwise block the rendering of the entire route

Streaming is integrated into the Next.js App Router by default

```tsx

import { Suspense } from "react";

import { Product } from "@/components/product";
import { Reviews } from "@/components/reviews";

export default function ProductDetailPage() {
    return (
        <div>
            <h1>Product detail page</h1>

            <Suspense fallback={<p>Loading product details .....</p>} >
                <Product />
            </Suspense>

            <Suspense fallback={<p>Loading Review .....</p>}>
                <Reviews />
            </Suspense>
        </div>
    );
}

```

## Server and Client Composition Patterns

###  Server components

- Fetching data
- Directly accessing backend resources 
- Protecting sensitive information (like access tokens and API keys) on the server 
- Keeping large dependencies server-side, which helps in reducing client-side JavaScript.

Client components
- Adding interactivity
- Handling event listeners (such as onClick(), onChange), etc
- Managing state and lifecycle effects (using hooks like useState(),
useReducer(), useEffect())
- Using browser-exclusive APIs
- Using custom hooks
- Using React Class components.


## Server-only Code

Certain code is intended to execute only on the server

You might have modules or functions that use multiple libraries, use environment variables, interact directly with a database, or process confidential information 

Since JavaScript modules can be shared, it's possible for code that's meant only for the server to unintentionally end up in the client

If server-side code gets bundled into the client-side JavaScript, it could lead to a bloated bundle size, expose secret keys, database queries, and sensitive business logic

It is crucial to separate server-only code from client-side code to protect the application's security and integrity


### server-only Package 

Provide a build-time error if developers accidentally import one of these modules into a Client Component

```npm i server-only```

```tsx
import "server-only"

export const serverSideFunction = () => {
    console. log(
    `use multiple libraries,
    use environment variables, interact with a database,
    process confidential information`) 

    return "server result";
}

```

##  Third-party Packages

Third-party packages in the ecosystem are gradually adapting, beginning to add the "use client" directive to components that rely on client-only features, marking a clear distinction in their execution environment

Many components from npm packages, which traditionally leverage client-side features, haven't yet integrated this directive

The absence of "use client" means that while these components will function correctly in Client Components, they may encounter issues or might not work at all within Server Components

To address this, you can wrap third-party components that rely on client-only features in your own Client Components

```tsx
import ImageSlider from "@/components/imageSlider"
import { serverSideFunction } from "@/utils/server-utils"

export default function ServerRoutePage() {
    console.log("Server route rendered")
    const result = serverSideFunction()
  return (
    <div>
        <div>ServerRoutePage</div>
        <p>{result}</p>
        <ImageSlider/>
          
    </div>
    )
}
```
```tsx
"use client";

import React from 'react';
import Slider from 'react-slick';
import 'slick-carousel/slick/slick.css';
import 'slick-carousel/slick/slick-theme.css';


export default function ImageSlider() {
    const settings = {
        dots: true,
      };
      return (
        <div className="image-slider-container">
          <Slider {...settings}>
            <div>
              <img src="http://picsum.photos/400/200" />
            </div>
            <div>
              <img src="http://picsum.photos/400/200" />
            </div>
            <div>
              <img src="http://picsum.photos/400/200" />
            </div>
            <div>
              <img src="http://picsum.photos/400/200" />
            </div>
          </Slider>
        </div>
      );
}
```


## Context Providers

Context providers are typically rendered near the root of an application to share global application state and logic

For example, the application theme

However, since React context is not supported in Server Components, attempting to create a context at the root of your application will result in an error

To address this, you can create a context and render its provider inside a separate Client Component

```tsx
"use client";
import { createContext, useContext } from "react";
type Theme = {
    colors: {
        primary: string;
        secondary: string;
    };
};
const defaultTheme: Theme = {
    colors: {
        primary: "#007bff",
        secondary: "#6c757d",
    },
};
const ThemeContext = createContext<Theme>(defaultTheme);
export const ThemeProvider = ({ children }: { children: React.ReactNode }) => {
    return <ThemeContext.Provider value={defaultTheme}>{children}</ThemeContext.Provider>;
};
export const useTheme = () => useContext(ThemeContext);
```
```tsx
<ThemeProvider>
    <body className={inter.className}>{children}</body>
</ThemeProvider>
```

```tsx
import { useTheme } from '@/components/theme-provider';
export default function ClientRoutePage() {
    const theme = useTheme()
    const settings = {
        dots: true,
      };
      return (
        <div>
            <h1 style={{color:theme.colors.primary}}>Client Route</h1>
```

## Client-only Code
important to confine some functionality to the client side
Just as it's important to restrict certain operations to the server it's equally

Client-only code typically interacts with browser-specific features like the DOM, the window object, localStorage etc which are not available on the server server-side rendering

Ensuring that such code is executed only on the client side prevents errors during server-side rendering

To prevent unintended server side usage of client side code, we can use a package called client-only

```npm i client-only```
```tsx
import 'client-only'

export const clientSideFunction = () => {
    console.log(
      `use window object,
       use localStorage`
    );
    return "client result";
  };
```

## Client Component
Placement To compensate for server components not being able to manage state and handle interactivity, you need to create client components 

It's recommended to position these client components lower in your component tree

![alt text](<images/Screenshot 2024-07-05 at 11.59.54 AM.png>)

```tsx
"use client"
import { useState } from "react";
import { NavLinks } from "./nav-links";
import { NavSearch } from "./nav-search";

export const Navbar = () => {
  console.log(`Navbar rendered`);
  const [search, setSearch] = useState("")
  return (
    <div>
      <NavLinks />
      <NavSearch />
    </div>
  );
};
```
Instead of above use like this
```tsx
"use client";

import { useState } from "react";

export const NavSearch = () => {
  const [search, setSearch] = useState("");

  console.log(`NavSearch rendered`);
  return <div>Nav search input</div>;
};
```

## Interleaving Server and Client Components

```tsx
import ClientComponentOne from "@/components/client-component-one";
import ServerComponentOne from "@/components/server-component-one";

export default function InterleavingPage() {
    return (
        <>
            <div>InterleavingPage</div>
            {/* <ServerComponentOne />
            <ClientComponentOne/> */}
            <ClientComponentOne>
                <ServerComponentOne /> //it use fs system we use directly in client componet it will treated as client side to treat as a server side we can send it as a children
            </ClientComponentOne>
        </>
    );
}
```
```tsx
export default function ClientComponentOne({children}:{children:React.ReactNode}){return (
        <div>
            <h1>client-component-one</h1>
            {children}
            {/* <ClientComponentTwo /> */}
        </div>
    );
}
```

## Data Fetching

### Data Fetching in App Router 

App Router uses the React Server Components (RSC) architecture, which allows us to fetch data using either server components or client components 

It's advantageous to fetch data using server components, as they have direct access to server-side resources such as databases or file systems 

This not only taps into the server's computational power and proximity to data sources for efficient data fetching and rendering but also minimizes the need for client-side processing

We will explore data fetching techniques using both server and client components in Next.js 

Server components support various configurations for caching, revalidating, and optimizing data fetching 

On the client side, data fetching is typically managed through third-party libraries such as ```TanStack Query``` which offers its own robust APIs

------------------

Fetching Data with Server Components 

The RSC architecture in the app router introduces support for async and await keywords in Server Components 

This allows you to use the familiar JavaScript await syntax by defining your component as an asynchronous function

This is the basis for data fetching in server components
```tsx
type User = {
    id: number;
    name: string;
    username: string;
    email: string;
    phone: string;
};

export default async function UsersPage() {
    const response = await fetch("https://jsonplaceholder.typicode.com/users");
    const users = await response.json();
    console.log(users);

    return (
        <div className="grid grid-cols-3 gap-2 p-4">
            {users.map((user: User) => (
                <div key={user.id} className="flex items-center justify-between p-4 bg-white shadow rounded-lg text-gray-600">
                    <div className="flex flex-col space-y-1">
                        <h2 className="text-lg font-semibold">{user.name}</h2>
                        <p className="text-sm ">{user.username}</p>
                    </div>
                    <div className="flex flex-col space-y-1 items-end">
                        <div className="text-md">{user.email}</div>
                        <div className="text-md">{user.phone}</div>
                    </div>
                </div>
            ))}
        </div>
    );
}
```


### Loading and Error States

Traditionally in React, you might manage these states by creating separate variables and conditionally rendering Ul based on their values

To implement a loading state, define and export a React component in ```loading.tsx ```

For handling errors, define and export a React component in ```error.tsx```

![alt text](<images/Screenshot 2024-07-05 at 1.13.12 PM.png>)


```npm install json-server@0.17.4  ```

## Caching Data

By default, Next.js automatically caches the returned values of fetch in the Data
Cache on the server

-----------------

### Data Cache
<u><b>What is data cache? </b></u>

It is a server-side cache that persists the result of data fetches across incoming
server requests and deployments

<u><b>Why is it required? </b></u>
The data cache improves app performance and reduces costs by eliminating the
need to re-fetch data from your data source with every request

<u><b>How does it work?</b></u>
![alt text](<images/Screenshot 2024-07-05 at 1.40.45 PM.png>)

-----------------

### Opting Out Of Caching 

For individual data fetches, you can opt out of caching by setting the cache option
to no-store 

Once you specify the no-store option for a fetch request, subsequent fetch
requests will also not be cached

```tsx
 const response = await fetch("http://localhost:3001/products",{
      cache:"no-store"
    })
```

By default, Next.js will cache fetch requests that occur before any dynamic functions (cookies), headers, searchParams are used and will not cache requests found after dynamic functions

[FetchCache Documentation next.js](https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config#fetchcache)

--------------------

## Request Memoization 

Request memoization is a technique that deduplicates requests for the same data
within a single render pass 

This approach allows for re-use of data in a React Component tree, prevents
redundant network calls and enhances performance 

For the initial request, data is fetched from an external source and the result is
stored in memory 

Subsequent requests for the same data within the same render pass retrieve the
result from memory, bypassing the need to make the request again
 
This optimization not only enhances performance but also simplifies data fetching
within a component tree 

When the same data is needed across different components in a route (e.g., in a Layout, Page, and multiple components), it eliminates the need to fetch data at the
top of the tree and pass props between components 

```tsx
export default async function Layout({ children }: { children: React.ReactNode }) {
    const productResponse = await fetch("http://localhost:3001/products/1");
    const products = await productResponse.json();
    console.log({products})
    return <>{children}</>;
}

```

Instead, data can be fetched directly within the components that require it, without concerns about the performance implications of multiple network requests for the same data

![alt text](<images/Screenshot 2024-07-05 at 2.28.35 PM.png>)

Request memoization is a React feature, not specifically a Next.js feature

Memoization only applies to the GET method in fetch requests 

Memoization only applies within the React Component tree. It does not extend to
fetch requests in Route Handlers as they are not part of the React component tree

For cases where fetch is not suitable (e.g., some database clients, CMS clients, or
GraphQL clients), you can use the React cache function to memoize functions



## Caching in Next.js

By default, Next.js caches all fetch requests in the data cache, which is a persistent HTTP cache on the server

This helps optimize pages such as a blog post where the content rarely changes

We also know that we can opt out of caching
- by using the cache: "no-store" option in a fetch request
- by using a dynamic function before making the fetch request
- by using a route segment config like fetch-cache or dynamic

A news website is a great example where you want to make sure you're fetching the latest data at all times.

This approach seems binary: either caching or no caching

In real-world applications, there are scenarios where a middle ground is required

For example, an event listings page might have event details such as schedule or
venue information that change occasionally 

In this case, it is acceptable to fetch updated data once every hour as freshness is not critical

For such scenarios, Next.js allows us to revalidate the cache.


## Revalidation 

Revalidation is the process of purging the Data Cache and re-fetching the latest
data

<u><b>Time-based revalidation</b></u>
Next.js automatically revalidates data after a certain amount of time has passed

```tsx
const response = await fetch("http://localhost:3001/products", {
       next:{
        revalidate:10 //10 sec
       }
    });
    const products = await response.json();
```
You can set the revalidate route segment configuration to establish the default
revalidation time for a layout or page: ```export const revalidate = 10;``` 

Regarding the revalidation frequency, the lowest revalidate time across each layout and page of a single route will determine the revalidation frequency of the
entire route













[Learn From Codevolution](https://www.youtube.com/watch?v=ZjAqacIC_3c&list=PLC3y8-rFHvwjOKd6gdf4QtV1uYNiQnruI)