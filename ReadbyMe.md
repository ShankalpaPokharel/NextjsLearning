# NextjsLearning 

<b>React framework to build web application (production ready)</b>
It uses react for building user interfaces, providedes additional features that enable you to build produciton-ready applications. These feature include routing, optimized rendering, data fetching, bundling, compiling and more. (don't need additional packages , opinions and conventions should be follwed to implement these)

## Why learn Next.js ? 
Next.js simplifies the process of building a web application for production : 

1. Routing (don't need to install thrid party, offers file base of routing)
2. API routes
3. Rendering(support both server and client side)
4. Data fetching
5. Styling
6. Optimizing
7. Dev and prod build system(focus on coding rather than setup)


## React Server Componets (RSC)

React SErver compoents is a new architecture introduced by the React team in version 18 which was quickly embraced by Nexrt.js

The architectture introduces a new way of creating React components, splitting them in two types:
- ### Server components
    - In Next.js, all components are Server components by default. 
    - They have the ability to ruun tasks like reading files or fetching data from a database.
    - However, they don't have the ability to use hooks or handle user interaction 
- ### Client Components 
    - To create a Client components, it's necessary to add ```use client``` at the top of the component file. 
    - Client components can't perform tasks like reading files, but they have the ability to use hooks and manage interactions. 
    - It is traditional react components. 

## Routing

Next.js has a file-system based routing mechanism
URL paths that users can access in the browser are defined by files and folders in your codebase

### Routing Conventions
All routes must be placed inside the app folder
Every file that corresponds to a route must be named page.js or page.tsx
Every folder corresponds to a path segments in the browers url

![alt text](<Screenshot 2024-07-03 at 1.38.12 PM.png>)

### Nested Routes

![alt text](<images/Screenshot 2024-07-03 at 1.44.40 PM.png>)
![alt text](<images/Screenshot 2024-07-03 at 1.46.01 PM.png>)

### Dynamic Routes
![alt text](<images/Screenshot 2024-07-03 at 1.47.57 PM.png>) 
![alt text](<images/Screenshot 2024-07-03 at 2.01.25 PM.png>)
![alt text](<images/Screenshot 2024-07-03 at 2.02.06 PM.png>)

### Nested Dynammic Routes

![alt text](<images/Screenshot 2024-07-03 at 2.03.55 PM.png>)

![alt text](<images/Screenshot 2024-07-03 at 2.10.09 PM.png>)
![alt text](<images/Screenshot 2024-07-03 at 2.10.51 PM.png>)

### Catch-all Segments

![alt text](<images/Screenshot 2024-07-03 at 2.14.38 PM.png>)

![alt text](<images/Screenshot 2024-07-03 at 2.26.11 PM.png>)

![alt text](<images/Screenshot 2024-07-03 at 2.27.30 PM.png>)

### Not found Page
![alt text](<images/Screenshot 2024-07-03 at 2.36.23 PM.png>)



## File Colocation
File colocation refers to the practice of organizing and placing files close to where they are used or relevant within the project structure.

To return content should be defalut export function without it page doen't return anythings

## Private Folder
Private folder indeicated that is a private implementation detail and should not be considered by the routing system. 

The folder and all its subfolders are excluded from routing

Prefix the folder name with an underscore

For separating UI logic from routing logic
For consistentlly organizing internal files across a project
For sorting and grouping files in code ediotrs
And finally, for avoiding potential naming conflicts with future Next.js file conventions. 
If you want to include an undercore in URL segments, you can prefix the foder name with "%5F" which is the URL -encoded form of an underscore, if you use %5F it will become route. 

![alt text](<images/Screenshot 2024-07-03 at 4.39.07 PM.png>)

## Route Groups
Allow us to logically group our routes and project files without affecting the URL path structure 

naming convention ```(group_name)```

Let's implement authentication routes
 - Register
 - Login
 - Forget password

![alt text](<images/Screenshot 2024-07-03 at 4.50.06 PM.png>)

## Layouts
A page is UI that is unique to a route

A layout is UI that is shared between multiple pages in the app
___________
| Header  |
-----------
| Contet  |
-----------
| Footer  |
-----------

### How to create Layouts
You c  an define a layout by default exporting a React component from a layout.js or layout.tsx file 
That component should accept a children prop that will be populated with a child page rendering

![alt text](<images/Screenshot 2024-07-03 at 5.06.12 PM.png>)

```tsx
export const metadata = {
    title: "Hello from Next.js",
    description: "Generated by Next.js",
};

export default function RootLayout({ children }: { children: React.ReactNode }) {
    return (
        <html lang="en">
            <body>
                <header style={{backgroundColor:"lightblue",padding:"1rem"}}>
                    <p>header</p>
                </header>
                {children}
                <footer style={{backgroundColor:"ghostwhite",padding:"1rem"}}>
                    <p>Footer</p>
                </footer>
            </body>
        </html>
    );
}

```

### Nested Layout
```tsx
<!-- routing-demo/src/app/products/[productId]/layout.tsx -->

export default function ProductDetailsLayout({ children }: { children: React.ReactNode }) {
    return (
        <>
            {children}
            <h2>Feature Products</h2>
        </>
    );
}

```


![alt text](<images/Screenshot 2024-07-03 at 5.14.26 PM.png>)


### Route Group Layout

Route Group uses:
 - To organize your project in a manner that doesn't affect URL
 - To selectively apply a layout to certain segments while leaving others unchanged

 ![alt text](<images/Screenshot 2024-07-03 at 5.34.34 PM.png>)


 ## Routing Metadata
 Ensuring proper search engin optimization(SEO) is crucial for increasing visibility and attractting users

 Next.js introduced the Metadata API which allows you to define metadata for each page

Metadata ensures accurate and relevant information is displyed when your pages are shared or indexed

### Configuring Metadata

- Export a static metadata object
- Export a dynamic generated Meatadata function

### Metadata rules
Both layout.tsx and page.tsx fiels can export metadata. If defined in a layout, it applies to all pages in that layout, but if defined in a pge, it applies only to that page. 

Metadata is read in order, from the root level down to the final page page level. 

When there's metadata in multiple places for the save route, but page metadata will replace layout metadata if they have the same properties. 

```ts
export const metadata = {
  title:"About Codevolution"
}

export default function page() {
  return (
    <div>Welcome about</div>
  )
}

```
```ts
import { Metadata } from "next";
import { resolve } from "path";

type Props = {
    params: { productId: string };
};

export const generateMetadata = async ({ params }: Props): Promise<Metadata> => {
    const title = await new Promise((resolve) => {
        setTimeout(() => {
            resolve(`iPhone ${params.productId}`);
        }, 100);
    });
    return { title: `Product ${title}` };
    // return { title:`Product ${params.productId}` }
};

export default function ProductDetails({ params }: Props) {
    console.log(params);
    return <div>Details about product {params.productId}</div>;
}

```


<b> You can't export both  the metadata object and generate metadata fucntion from same route segment</b>


### title Metadata
The title field's primary purpose is to define the document title
It can be either a string or an object 

```ts

import { Metadata } from "next";

export const metadata:Metadata = {
    title: {
        absolute:"",
        default:"Learning Next.js",
        template:"%s | Shankalpa"
    },
    description: "Generated by Next.js",
};

```
```ts
import { Metadata } from "next"

export const metadata:Metadata = {
  title:{
    absolute:"blog" //tille will be blog don't follow the template when use absolute
  }
}

export default function SecondBlog() {
  return (
    <div>SecondBlog Post</div>
  )
}

```



## Navigation
File based routing

We manually entered the URLKs in the browser's adress bar to navigate to the different route

User rely on UI elements like links to navigate:
 - Clicking on them or
 - Through programmatic navigation after completing an action


![alt text](<images/Screenshot 2024-07-03 at 8.23.09 PM.png>)

### Link Componet Navigation

To enable client-side navigation Next.js provides us wiht the Link component. 

The ```<Link>``` component is a React component that extends the HTML ```<a>``` element,  and it's the primary way to navigate between routes in Next.js. 

To use it, we need to import it from ```next/link```

The```replace``` attribute is used to replace the current entry in the browser's history stack instead of adding a new one. This can be useful when you want to navigate without keeping the previous URL in the history.

```tsx
import Link from "next/link"

export default function page() {
  const productId = 100
  return (
    <>
    <Link href="/"> Home</Link>
    <div>Product List</div>
    <h2> <Link href="products/1">Product 1</Link></h2>
    <h2> <Link href="products/2">Product 2</Link></h2>
    <h2> <Link href="products/3" replace>Product 3</Link></h2>
    <h2> <Link href={`products/${productId}`}>Product {productId}</Link></h2>
    </>
  )
}

```

### Active Links
```jsx
"use client"
import Link from "next/link";
import { usePathname } from "next/navigation";
import "./style.css"

const navLinks = [
    { name: "Register", href: "/register" },
    { name: "Login", href: "/login" },
    { name: "Forgot Password", href: "/forgot-password" },
];

export default function AuthLayout({ children }: {children: React.ReactNode}) {
    const pathname = usePathname()
   
    console.log(pathname)
    return (
        <div>
            {navLinks.map((link) => {
                const isActive = pathname.startsWith(link.href)
                return <Link href={link.href} key={link.name} className={isActive ? "font-bold mr-4":"text-blue-500 mr-4"}>{link.name}</Link>;
            })}
            {children}
        </div>
    );
}

```

### Navigating Pprogrammatically
![alt text](<images/Screenshot 2024-07-03 at 9.06.42 PM.png>)
![alt text](<images/Screenshot 2024-07-03 at 9.07.25 PM.png>)

```tsx
"use client"
import { useRouter } from "next/navigation"

export default function OrderProduct() {
    const router = useRouter()
    const handleClick = ()=>{
        console.log("Placing your order")
        router.push("/")
        // router.replace("/")
        // router.back()
        // router.forward()
    }
  return (
    <>
    <h1>Order Product</h1>
    <button onClick={handleClick}>Place order</button>
    </>
  )
}
```

## Templates
Templates are similar to layouts in that they wrap each child layout or page. 

But, with templates, when a user navigates between routes that share a template, a new instance of the components is mounted, DOM elements are recreated, state is not preserved , and effects are re-syncghronized. 

A template can be defined by exporting a default React component from a template.js or template.tsx file. 

Similar to layouts, templates also should accept a children props which will render the nested segments in the route. 

![alt text](<images/Screenshot 2024-07-04 at 9.45.41 AM.png>)

## Special Files
 - page.tsx
 - layout.tsx
 - template.tsx
 - not-found.tsx
 - loading.tsx
 - error.tsx

### loading.tsx 
This file allows us to create loading states that are displayed to users while a specific route segments's content is loading. 

The loading state appears immediatelly upon navigation, giveing users the assurance that the application is responsive and actively loading content. 

<b>It is like React Loading Skeleton</b>

### loading.tsk Benefits
1. You can disply the loading state as soon as a user navigates to a new route 
    The immediate feedback reassures user theat their actions has been acknowledged, reduces preceived loading times, and makes the application feel more responsive. 

2. Next.js allows the creation of shared layouts that remain interactive while new route segments are loading. 

    User can continue interacting with crtain parts of the application, asuch as a navigation menu or sidebar, if the main content is still being fetched. 


### error.tsx
![alt text](<images/Screenshot 2024-07-04 at 10.07.37 AM.png>)

Automatically wrap a route segment and it's nested children in a React Error Boundary

Create error UI tailored ot specific segents using the file-system hierarchy to adjust granularity

Isolate error to affected segments while keeping the rest of the application functional

Add functionality to attempt to recover from an error without a full page reload.

### Component Hierachy

![alt text](<images/Screenshot 2024-07-04 at 10.10.43 AM.png>)

### Recover From Error using reset
![alt text](<images/Screenshot 2024-07-04 at 10.16.38 AM.png>)


### Handling Errros in Nested Routes
Error bubble up to the closest parent error boundary

An error.tsx file will cater to errors for all its nested child segments

By positoning error.tsx files at different levels in the nested folders of a route, you can achive a more granular level of error handling. 


### Handling Errors in Layouts

An error.tsx file will handle errors for all its nested child segments

The error boundary doesn't catch error thrown here because it's nested inside the layout component.

![alt text](<images/Screenshot 2024-07-04 at 10.10.43 AM.png>)

![alt text](<images/Screenshot 2024-07-04 at 10.33.44 AM.png>)


## Parallel Routes
Parallel routes are an advanced routing mechanism that allows for the simultaneous rendering of multiple pages within the same layout

![alt text](<images/Screenshot 2024-07-04 at 10.37.26 AM.png>)


    - Parallel routes in Next.js are defined using a feature known as slots
    - Slots help structure our content in a modular fashion
    - To define a slot, we use the @folder naming convention
    - Each slot is then passed as a prop to its corresponding 'layout.ts' file.

![alt text](<images/Screenshot 2024-07-04 at 10.45.06 AM.png>)

### Parallel Routes Benefits 

A clear benefit of parallel routes is their ability to split a single layout into various slots, making the code more manageable

Independent route handling

Sub-navigation

```tsx
export default function DashboardLayout({
    children,
    users,
    revenue,
    notifications,
}: {
    children: React.ReactNode;
    users: React.ReactNode;
    revenue: React.ReactNode;
    notifications: React.ReactNode;
}) {
    return (
        <>
            <div>{children}</div>
            <div style={{ display: "flex" }}>
                <div style={{ display: "flex", flexDirection: "column" }}>
                    <div>{users}</div>
                    <div>{revenue}</div>
                </div>
                <div style={{ display: "flex", flex: 1 }}>{notifications}</div>
            </div>
        </>
    );
}

```

### Independent Route Handling 
Each slot of your layout, such as user analytics or revenue metrics, can have its own loading and error states 

This granular control is particularly beneficial in scenarios where different sections of the page load at varying speeds or encounter unique errors

![alt text](<images/Screenshot 2024-07-04 at 11.08.13 AM.png>)

### Sub-navigation in routes 

Each slot of your dashboard can essentially function as a mini-application,
complete with its own navigation and state management 

This is especially useful in a complex application such as our dashboard where different sections serve distinct purposes.

![alt text](<images/Screenshot 2024-07-04 at 11.09.57 AM.png>)


### Unmatched Routes
<b><u>Navigation from the Ul</u></b>

In the case of navigation within the Ul, Next. js retains the previously active state of a slot regardless of changes in the URL.

<b><u>Page reload</u></b>


Next.js immediately searches for a default.ts file within each unmatched slot. 

The presence of this file is critical, as it provides the default content that Next.js will render in the user interface

If this default.ts file is missing in any of the unmatched slots for the current route, Next.js will render a 404 error.


### default.tsx 


The ```default.tsx``` file in Next.js serves as a fallback to render content when the framework cannot retrieve a slot's active state from the current URL 
You have complete freedom to define the Ul for unmatched routes: you can either mirror the content found in page.ts or craft an entirely custom view

![alt text](<images/Screenshot 2024-07-04 at 11.35.29 AM.png>)


## Intercepting routes

Intercepting routes allow you to intercept or stop the default routing behaviour to present an alternate view or component when navigating through the Ul, while still preserving the intended route for scenarios like page reloads 

This can be useful if you want to show a route while keeping the context of the current page


![alt text](<images/Screenshot 2024-07-04 at 4.21.11 PM.png>)

![alt text](<images/Screenshot 2024-07-04 at 4.22.40 PM.png>)

### Intercepting Routes Conventions

    - (.) to match segment on the same level

![alt text](<images/Screenshot 2024-07-04 at 4.37.02 PM.png>)

    - (..) to match segments one level above 

![alt text](<images/Screenshot 2024-07-04 at 4.46.56 PM.png>)


    - (..)(..) to match segments two levels above
    - (...) to match segments from the root app directory


[Code of Photo gallary intercepiing routing source](https://github.com/gopinav/Next.js-14-Tutorials/tree/main/routing-demo/src/app/photo-feed)
 



## Route Handlers
We've learnt how to route to pages 

    - We can also create custom request handlers for our routes using a feature called route handlers 

    - Unlike page routes, which respond with HTML content, route handlers allow you to create RESTful endpoints, giving you full control over the response

    - There is no overhead of having to create and configure a separate server

    - Route handlers are also great for making external API requests 

    - Route handlers run server-side, ensuring that sensitive information like private keys remains secure and never gets shipped to the browser

    - Route Handlers are the equivalent of API routes in Page router

![alt text](<images/Screenshot 2024-07-04 at 5.19.11 PM.png>)

### Get Request

![alt text](<images/Screenshot 2024-07-04 at 5.34.19 PM.png>)

![alt text](<images/Screenshot 2024-07-04 at 5.35.17 PM.png>)


### Post Request 
```tsx
export async function POST(request:Request) {
    const comment = await request.json()
    console.log("comment  .. ",comment)
    const newcomment = {
        id:comments.length +1,
        text:comment.text
    }
    comments.push(newcomment)
    return new Response(JSON.stringify(newcomment),{
        headers:{
            "Content-Type":"application/json"
        },
        status:201
    })
    // return Response.json(newcomment)
}

```

### Dynamic route handler
```ts
import {comments} from "../data"

export async function GET(_request:Request,{params}:{params:{id:string}}) {
    const comment = comments.find(comment => comment.id === parseInt(params.id))
    return Response.json(comment);
}
```


### PATCH Request

```ts
// http://localhost:3000/comments/2
// json Content
// {
//     "text":"Updated Comment"
//   }
export async function PATCH(request: Request, { params }: { params: { id: string } }) {
    const body = await request.json()
    const {text}= body
    const index = comments.findIndex(
        comment =>comment.id === parseInt(params.id)
    )
    comments[index].text = text;
    
    return Response.json(comments[index]);
}

```

### Delete Request 
```ts
export async function DELETE(request: Request, { params }: { params: { id: string } }) {

   
    const index = comments.findIndex(
        comment =>comment.id === parseInt(params.id)
    )
    const deletedComment = comments[index]
    comments.splice(index,1)
    
    return Response.json(deletedComment);
    
}

```

### URL Query Parameters

```ts
import { comments } from "./data";
import { type NextRequest } from "next/server";

export async function GET(request:NextRequest) {
    const searchParams = request.nextUrl.searchParams
    const query = searchParams.get("query")
    const filteredComments = query 
        ? comments.filter(comment => comment.text.includes(query))
        : comments
    return Response.json(filteredComments)
}

```


### Redirect in Route Handler
```ts
export async function GET(_request: Request, { params }: { params: { id: string } }) {
    
    if (parseInt(params.id) >comments.length){
        redirect("/comments")
    }

    const comment = comments.find((comment) => comment.id === parseInt(params.id));
    return Response.json(comment);
}
```

### Header in Route Handlers

HTTP headers represent the metadata associated with an API request and
response.

<u><b>Request Headers </b></u>

These are sent by the client, such as a web browser, to the server. They contain essential information about the request, which helps the server understand and process it correctly.

```User-Agent``` which identifies the browser and operating system to the server. 

```Accept``` which indicates the content types like text, video, or image formats that the client can process.

```Authorization``` header used by the client to authenticate itself to the server

<u><b>Response Headers </b></u>

These are sent back from the server to the client. They provide information about the server and the data being sent in the response.

```Content-Type``` header which indicates the media type of the response. It tells the client what the data type of the returned content is, such as text/html for HTML
documents, application/json for JSON data, etc.

```ts
import { type NextRequest } from "next/server"
// or 
import { headers } from "next/headers"

export async function GET(request:NextRequest) {
    const requestHeaders = new Headers(request.headers)
    // or 
    const headerList = headers()

    console.log(requestHeaders.get("Authorization"))
    // or 
    console.log(headerList.get(("Authorization")))

    return new Response("profile data",{
       headers:{
         "Content-Type":"text/html",
         "Set-Cookie" : "theme=dark"
       }
    })
}
```

### Cookies in Route Handlers

Cookies are small pieces of data that a server sends to a user's web browser The browser may store the cookie and send it back to the same server with later requests

Cookies are mainly used for three purposes

- Session management like logins and shopping carts
- Personalization like user preferences and themes
- Tracking like recording and analyzing user behavior.

```ts
import { cookies } from "next/headers"

export async function GET(request:NextRequest) {
    const requestHeaders = new Headers(request.headers)
    // or 
    const headerList = headers()

    cookies().set("resultsPerPage","20") //one way to set cookie 
    console.log(cookies().get("resultsPerPage"))

    // get cookie 
    const theme = request.cookies.get("theme")
    console.log(theme)

    console.log(requestHeaders.get("Authorization"))
    // or 
    console.log(headerList.get(("Authorization")))

    // cookies() has delete has set size function 

    return new Response("profile data",{
       headers:{
         "Content-Type":"text/html",
         "Set-Cookie" : "theme=dark" //anoter way to set cookies
       }
    })
}
```

### Caching in Route Handlers 

Route Handlers are cached by default when using the GET method with the Response object in Next.js

How to opt out of caching?
- dynamic mode in Segment Config Option
- using the Request object with the GET method
- employing dynamic functions like headers) and cookies)

```ts
export const dynamic = "force-dynamic"; //by default it is aut o; doing this
//because after bulid time doens't change cause of caching

export async function GET() {
    return Response.json({
        time:new Date().toLocaleTimeString()
    })
}
```


## Middleware

Middleware in Next.js is a powerful feature that offers a robust way to intercept and control the flow of requests and responses within your applications 

It does this at a global level significantly enhancing features like redirection, URL rewrites, authentication, headers and cookies management, and more.
  
Middleware allows us to specify paths where it will be active
- Custom matcher config
```ts
//src/middleware.ts
import { NextResponse, type NextRequest } from "next/server";

export function middleware(request:NextRequest){
    return NextResponse.redirect(new URL("/",request.url))
}

export const config = {
    matcher:"/profile"
}

```


- Conditional statements.

```ts
import { NextResponse, type NextRequest } from "next/server";

export function middleware(request:NextRequest){
if(request.nextUrl.pathname === "/profile"){
    // return NextResponse.redirect(new URL(("/hello"),request.url))
    return NextResponse.rewrite(new URL(("/hello"),request.url)) //doesn't chagne the url but content will be change
}
}

```
```ts
import { type NextRequest, NextResponse } from "next/server";

export function middleware(request:NextRequest){
    const response = NextResponse.next()

    const themePreference = request.cookies.get("theme")

    if(!themePreference){
        response.cookies.set("theme","dark")
    }
    response.headers.set("custom-header","custom-value1")
    return response
```
### Routing Section Summary
- Route definition
- Pages and layouts
- Dynamic routes
- Route groups
- Linking and Navigation
- Handling errors in routes
- Parallel and Intercepting routes
- Route handlers and middleware


























[Learn From Codevolution](https://www.youtube.com/watch?v=ZjAqacIC_3c&list=PLC3y8-rFHvwjOKd6gdf4QtV1uYNiQnruI)